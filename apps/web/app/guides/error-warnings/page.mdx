# Error warnings

Some API's need a Suspense boundary to work correctly like `useSearchParams` from **next**, sometimes
this hook can be used without any error on development mode, but once you compile the code,
it will throw an error due to missing Suspense boundary.

To fix this issue, you can extend this hook with the `SuspenseContext` provided by `suspense-fallback-debugger`.

For example, let's create a `useSearch` hook to handle the url query parameters.

First create a `use-search.ts` file.

```ts
"use client";

import type { Route } from "next";

import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useDebouncedCallback } from "use-debounce";

/**
 * This hook allows to handle URL state for search queries
 * preserving other query parameters and actual pathname
 *
 * @param name - The name of the search parameter, this will be placed on the URL as a query parameter
 * @param options - Options to configure the search behavior
 * @param options.debounceTime - The debounce time (time to wait before updating the URL) in milliseconds (**default: 400**)
 */
export function useSearch(
    name: string,
    {
        debounceTime = 400,
    }: { debounceTime?: number } = {},
) {
    const router = useRouter();
    const pathname = usePathname();
    const params = useSearchParams();

    const search = useDebouncedCallback(
        (e: React.ChangeEvent<HTMLInputElement> | string) => {
            const searchValue = typeof e === "string" ? e : e.target.value;
            const searchParams = new URLSearchParams(params);

            if (
                !searchValue ||
                searchValue.length === 0
            ) {
                searchParams.delete(name);
            } else {
                searchParams.set(name, searchValue);
            }

            router.replace(`${pathname}?${searchParams.toString()}` as Route);
        },
        debounceTime,
    );

    return { search };
}
```

This hook will handle search queries with a debounce time but we still have the problem with the `useSearchParams` hook not being wrapped in a `Suspense` boundary.

So let's fix it, import the `SuspenseContext` from `suspense-fallback-debugger` & read it with the `useContext` react hook.

```ts

"use client";

import type { Route } from "next";

import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useContext } from "react";
import { useDebouncedCallback } from "use-debounce";

import { SuspenseContext } from "suspense-fallback-debugger";
import { __IS__DEV__ } from "@/constants/isDev";

/**
 * This hook allows to handle URL state for search queries
 * preserving other query parameters and actual pathname
 *
 * @param name - The name of the search parameter, this will be placed on the URL as a query parameter
 * @param options - Options to configure the search behavior
 * @param options.debounceTime - The debounce time (time to wait before updating the URL) in milliseconds (**default: 400**)
 * @param options.clearOnValue - The value that will clear the search parameter from the URL
 */
export function useSearch(
    name: string,
    {
        debounceTime = 400,
        clearOnValue = "",
    }: { debounceTime?: number; clearOnValue?: string } = {},
) {

   /**
    *  Read it on the top of the component so will be used to check if the component is used within a <Suspense/> component
    */
    const context = useContext(SuspenseContext);

    /**
     * We only care if the component is used within a <Suspense/> component on development mode
     * so when building for production, we don't need to check for this since we already handled on development mode
     */
    if (__IS__DEV__ && !context) {
        throw new Error(
            `**useSearch("${name}")** must be used within a <Suspense/> component,
            you must import it from 'suspense-fallback-debugger'`,
        );
    }

    const router = useRouter();
    const pathname = usePathname();
    const params = useSearchParams();

    const search = useDebouncedCallback(
        (e: React.ChangeEvent<HTMLInputElement> | string) => {
            const searchValue = typeof e === "string" ? e : e.target.value;
            const searchParams = new URLSearchParams(params);

            if (
                !searchValue ||
                searchValue.length === 0 ||
                searchValue === clearOnValue
            ) {
                searchParams.delete(name);
            } else {
                searchParams.set(name, searchValue);
            }

            router.replace(`${pathname}?${searchParams.toString()}` as Route);
        },
        debounceTime,
    );

    return { search };
}

```

And thats it!

This way, we ensure that the search functionality is only used within a `<Suspense/>` component, and would'nt throw an error on building.

import { Alert, AlertDescription } from '@workspace/ui/components/alert';
import { AlertCircle } from 'lucide-react'

<Alert>
    <AlertCircle />
    <AlertDescription>
        Note that if you wrap the `useSearch` hook with the vanilla react `<Suspense/>` component, the hook even still throw an error since
        its looking for the suspense context, so you must import all your `<Suspense/>` from 'suspense-fallback-debugger'.
    </AlertDescription>
</Alert>
